{"meta":{"title":"蒟蒻sxy的blog","subtitle":null,"description":null,"author":"sxy","url":"http://www.sxyoi.cn"},"pages":[{"title":"tags","date":"2018-08-30T09:54:31.000Z","updated":"2018-08-30T09:55:58.719Z","comments":true,"path":"tags/index.html","permalink":"http://www.sxyoi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NOIp pj模拟赛1","slug":"NOIp普及模拟赛1","date":"2018-09-08T04:56:09.000Z","updated":"2018-09-08T05:12:51.711Z","comments":true,"path":"2018/09/08/NOIp普及模拟赛1/","link":"","permalink":"http://www.sxyoi.cn/2018/09/08/NOIp普及模拟赛1/","excerpt":"A 小A刚考完大学考试。现在已经出了n门课的成绩，他想自己先算一下这些课的绩点是多少。设第i门课的他拿到的绩点是gpai,而这门课的学分是sci，那么他的总绩点用下面的公式计算： , 换言之，设S为sci的和，T为gpai与sci的乘积的和。那么小A的绩点就是T除以S的值。","text":"A 小A刚考完大学考试。现在已经出了n门课的成绩，他想自己先算一下这些课的绩点是多少。设第i门课的他拿到的绩点是gpai,而这门课的学分是sci，那么他的总绩点用下面的公式计算： , 换言之，设S为sci的和，T为gpai与sci的乘积的和。那么小A的绩点就是T除以S的值。 输入描述: 第一行一个整数n。接下来n行，每行两个数gpai和sci。 输出描述: 输出一行一个实数，表示小A的绩点。输出四舍五入保留1位小数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define For(i,l,r) for(int i=l;i&lt;=r;++i) using namespace std;inline long long int read()&#123; char c; bool t=0; long long int a=0; while((c=getchar())==' '||c=='\\n'||c=='\\r'); if(c=='-') &#123; t=1;c=getchar(); &#125; while(isdigit(c)) &#123; a*=10;a+=(c-'0');c=getchar(); &#125; return a*(t?-1:1);&#125;long long int n,m,t,mx,my,q;char c;int main()&#123; long long int sx,sy; scanf(\"%lld %lld %lld\",&amp;n,&amp;m,&amp;t); while((c=getchar())==' '||c=='\\n'||c=='\\r'); while(c!=' '&amp;&amp;c!='\\n'&amp;&amp;c!='\\r') &#123; if(c=='U') mx+=-1; else if(c=='L') my+=-1; else if(c=='R') my+=1; else mx+=1; c=getchar(); &#125; mx=((mx%n)*(t%n))%n; my=((my%m)*(t%m))%m; scanf(\"%lld\",&amp;q); For(i,1,q) &#123; sx=read();sy=read(); sx=(sx+mx)%n; sy=(sy+my)%m; if(sx&lt;=0)sx+=n; if(sy&lt;=0)sy+=m; //if(!sx)sx=n; //if(!sy)sy=m; printf(\"%lld %lld\\n\",sx,sy); &#125; return 0;&#125; B 小A站在一个巨大的棋盘上。这个棋盘可以看成是一个网格图。这个网格图的大小为nm。左上角坐标为(1,1)，右下角坐标为(n,m)。这个棋盘很特别，他每行每列都是一个环。具体来说，当小A站在第一行，他往上走的时候，他会走到第n行，站在第n行往下走会走到第一行。对于第一列和第m列类似。小A在棋盘上可以上下左右走，假设他站在位置(i,j)，向上走，会走到(i-1,j)，向下回到(i+1,j)，向左到(i,j-1)，向右到(i,j+1)。注意由于棋盘是循环的，他不会走出这个棋盘。 现在小A有一个固定的行走序列S，代表他每一步走的方向，U代表向上，D代表向下，L代表向左，R代表向右。比如小A一开始在(1,1)，棋盘大小为34。行走序列为UULRD。那么他会依次经过(3,1),(2,1),(2,4),(2,1),(3,1)。但小A觉得只走一遍S太无聊，因此他会重复走这个序列T次。比如上面的例子，当T=2时，真正的行走序列为UULRDUULRD。 小A有q个备选的起点位置。他一开始先给定你棋盘大小与行走序列，对于每个起点位置，他想知道，他沿着序列走，最终会走到哪个位置停下。 输入描述: 第一行三个整数n,m,T。接下来一行一个字符串S，代表行走序列。注意行走序列在真实走的时候要重复T次。接下来一个整数q。接下来q行，每行两个整数x,y，代表小A的一个备选起点。 输出描述: 输出q行，每行两个整数，输出对于这个起点，最后的终点是哪里。 示例1 输入复制 3 6 4DUUUDLLLLR33 22 51 4 输出复制 2 21 53 4 备注: 20%: |S| T &lt;= 10^6, q = 140%: |S| T &lt;= 10^6, q &lt;= 10^560%: |S|, T &lt;= 10^5, q &lt;= 10^5100%: 1 &lt;= T,n,m &lt;= 10^9, 1 &lt;= x &lt;= n, 1 &lt;= y &lt;= m. 1&lt;= q, |S| &lt;= 10^5其中|S|代表S的长度。逐个字符读入，然后把所有操作加起来$t %n$和$t %m$ 然后再对每个坐标加上操作%n %m 然后特判一下非正数处理即可 $$O(|S|+q)$$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define For(i,l,r) for(int i=l;i&lt;=r;++i) using namespace std;inline long long int read()&#123; char c; bool t=0; long long int a=0; while((c=getchar())==' '||c=='\\n'||c=='\\r'); if(c=='-') &#123; t=1;c=getchar(); &#125; while(isdigit(c)) &#123; a*=10;a+=(c-'0');c=getchar(); &#125; return a*(t?-1:1);&#125;long long int n,m,t,mx,my,q;char c;int main()&#123; long long int sx,sy; scanf(\"%lld %lld %lld\",&amp;n,&amp;m,&amp;t); while((c=getchar())==' '||c=='\\n'||c=='\\r'); while(c!=' '&amp;&amp;c!='\\n'&amp;&amp;c!='\\r') &#123; if(c=='U') mx+=-1; else if(c=='L') my+=-1; else if(c=='R') my+=1; else mx+=1; c=getchar(); &#125; mx=((mx%n)*(t%n))%n; my=((my%m)*(t%m))%m; scanf(\"%lld\",&amp;q); For(i,1,q) &#123; sx=read();sy=read(); sx=(sx+mx)%n; sy=(sy+my)%m; if(sx&lt;=0)sx+=n; if(sy&lt;=0)sy+=m; //if(!sx)sx=n; //if(!sy)sy=m; printf(\"%lld %lld\\n\",sx,sy); &#125; return 0;&#125;","categories":[],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://www.sxyoi.cn/tags/比赛/"}]},{"title":"主席树入门：静态主席树","slug":"主席树入门：静态主席树","date":"2018-08-30T09:53:18.000Z","updated":"2018-09-08T05:13:31.659Z","comments":true,"path":"2018/08/30/主席树入门：静态主席树/","link":"","permalink":"http://www.sxyoi.cn/2018/08/30/主席树入门：静态主席树/","excerpt":"问题 首先用一个问题来引入： 给出n个数，m次查询，每次查询一个区间[l,r]中第k大的值","text":"问题 首先用一个问题来引入： 给出n个数，m次查询，每次查询一个区间[l,r]中第k大的值 sol 显然可以有一个O(nm)的暴力 那么我们考虑用线段树来做这道题 用裸的权值线段树可以支持询问数列中的第k大值，我们询问[l,r]中第k大的值，其实可以调用插入第l个数之前的权值线段树和插入第r个数之后的权值线段树，用它们的权值做差，其实就是一颗[l,r]的权值线段树 很容易想到可以构建n颗权值线段树，不过空间肯定会炸 那么我们考虑只更新那些有插入的点，没有更新到的点直接用上个版本的点来代替，这样每次插入一个数的新增空间是log n 这里就不能用之前普通的线段树那种左儿子(x&lt;&lt;1)右儿子((x&lt;&lt;1)|1)的方式来存储了 当然，一般还要把这些数离散化一下，如果数的范围小也可以不用离散化 我们就预先开好一个内存池一样的东西，新开点时直接从这里取就好了，new好像比较慢 模板题&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define For(i,l,r) for(int i=l;i&lt;=r;++i)#define MAXN (200010)#define mid ((l+r)&gt;&gt;1)using namespace std;int read()&#123; char c; bool t=0; int a=0; while((c=getchar())==' '||c=='\\n'||c=='\\r'); if(c=='-') &#123; t=1; c=getchar(); &#125; while(isdigit(c)) &#123; a*=10; a+=(c-'0'); c=getchar(); &#125; return a*(t?-1:1);&#125;int ls[MAXN&lt;&lt;5],rs[MAXN&lt;&lt;5],sum[MAXN&lt;&lt;5];int root[MAXN],cnt;//第i个版本的根节点，节点数int n,m,a[MAXN],hash[MAXN],len,ans;int getHash(const int &amp;x)//离散化检索&#123; return lower_bound(hash+1,hash+len+1,x)-hash;&#125;void build(int l,int r,int x)&#123; if(l==r) return; ls[x]=++cnt; build(l,mid,cnt); rs[x]=++cnt; build(mid+1,r,cnt); //printf(\"[l:%d r:%d x:%d ls:%d rs:%d]\\n\",l,r,x,ls[x],rs[x]);&#125;void update(int w,int l,int r,int x,int his)//要修改的值 左端 右端 要修改的点 要修改的点的前一个版本 &#123; if(l==r) &#123;sum[x]=sum[his]+1;return;&#125;//AAAA ls[x]=ls[his];rs[x]=rs[his];sum[x]=sum[his]+1; if(w&lt;=mid) &#123; ls[x]=++cnt; update(w,l,mid,cnt,ls[his]); &#125; else &#123; rs[x]=++cnt; update(w,mid+1,r,cnt,rs[his]); &#125; //sum[x]=sum[ls[x]]+sum[rs[x]];&#125;void ask(int l,int r,int rx,int lx,int k)//当前点左 当前点右 当前右点 当前左点 第k小 &#123; if(l==r) &#123; ans=hash[l]; return; &#125; if(k&lt;=sum[ls[rx]]-sum[ls[lx]])//在左边 ask(l,mid,ls[rx],ls[lx],k); else//在右边 ask(mid+1,r,rs[rx],rs[lx],k-sum[ls[rx]]+sum[ls[lx]]);&#125;int main()&#123; int tx,ty,tk; n=read();m=read(); For(i,1,n) a[i]=read(); memcpy(hash,a,sizeof a); sort(hash+1,hash+n+1); len=unique(hash+1,hash+n+1)-hash-1; root[0]=++cnt; build(1,len,cnt); For(i,1,n) &#123; root[i]=++cnt; update(getHash(a[i]),1,len,cnt,root[i-1]); &#125; For(i,1,m) &#123; tx=read();ty=read();tk=read(); if(tx==ty) &#123;printf(\"%d\\n\",a[tx]);continue;&#125; ask(1,len,root[ty],root[tx-1],tk); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.sxyoi.cn/tags/数据结构/"},{"name":"主席树","slug":"主席树","permalink":"http://www.sxyoi.cn/tags/主席树/"}]},{"title":"博客迁移","slug":"博客迁移","date":"2018-08-30T09:44:45.000Z","updated":"2018-08-30T09:50:34.681Z","comments":true,"path":"2018/08/30/博客迁移/","link":"","permalink":"http://www.sxyoi.cn/2018/08/30/博客迁移/","excerpt":"","text":"其他博客地址： csdn：https://blog.csdn.net/suxuyu01 Luogu：https://www.luogu.org/blog/lqyzsun/ 一般情况下不会再使用，如果在除此博客之外的地方发了我认为有价值的新文章也搬到这里来","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://www.sxyoi.cn/tags/日志/"}]}]}