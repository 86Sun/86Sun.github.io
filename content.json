{"meta":{"title":"蒟蒻sxy的blog","subtitle":null,"description":null,"author":"sxy","url":"http://www.sxyoi.cn"},"pages":[{"title":"tags","date":"2018-08-30T09:54:31.000Z","updated":"2018-08-30T09:55:58.719Z","comments":true,"path":"tags/index.html","permalink":"http://www.sxyoi.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"主席树入门：静态主席树","slug":"主席树入门：静态主席树","date":"2018-08-30T09:53:18.000Z","updated":"2018-08-30T11:11:33.906Z","comments":true,"path":"2018/08/30/主席树入门：静态主席树/","link":"","permalink":"http://www.sxyoi.cn/2018/08/30/主席树入门：静态主席树/","excerpt":"","text":"问题 首先用一个问题来引入： 给出n个数，m次查询，每次查询一个区间[l,r]中第k大的值 sol 显然可以有一个O(nm)的暴力 那么我们考虑用线段树来做这道题 用裸的权值线段树可以支持询问数列中的第k大值，我们询问[l,r]中第k大的值，其实可以调用插入第l个数之前的权值线段树和插入第r个数之后的权值线段树，用它们的权值做差，其实就是一颗[l,r]的权值线段树 很容易想到可以构建n颗权值线段树，不过空间肯定会炸 那么我们考虑只更新那些有插入的点，没有更新到的点直接用上个版本的点来代替，这样每次插入一个数的新增空间是log n 这里就不能用之前普通的线段树那种左儿子(x&lt;&lt;1)右儿子((x&lt;&lt;1)|1)的方式来存储了 当然，一般还要把这些数离散化一下，如果数的范围小也可以不用离散化 我们就预先开好一个内存池一样的东西，新开点时直接从这里取就好了，new好像比较慢 模板题&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define For(i,l,r) for(int i=l;i&lt;=r;++i)#define MAXN (200010)#define mid ((l+r)&gt;&gt;1)using namespace std;int read()&#123; char c; bool t=0; int a=0; while((c=getchar())==' '||c=='\\n'||c=='\\r'); if(c=='-') &#123; t=1; c=getchar(); &#125; while(isdigit(c)) &#123; a*=10; a+=(c-'0'); c=getchar(); &#125; return a*(t?-1:1);&#125;int ls[MAXN&lt;&lt;5],rs[MAXN&lt;&lt;5],sum[MAXN&lt;&lt;5];int root[MAXN],cnt;//第i个版本的根节点，节点数int n,m,a[MAXN],hash[MAXN],len,ans;int getHash(const int &amp;x)//离散化检索&#123; return lower_bound(hash+1,hash+len+1,x)-hash;&#125;void build(int l,int r,int x)&#123; if(l==r) return; ls[x]=++cnt; build(l,mid,cnt); rs[x]=++cnt; build(mid+1,r,cnt); //printf(\"[l:%d r:%d x:%d ls:%d rs:%d]\\n\",l,r,x,ls[x],rs[x]);&#125;void update(int w,int l,int r,int x,int his)//要修改的值 左端 右端 要修改的点 要修改的点的前一个版本 &#123; if(l==r) &#123;sum[x]=sum[his]+1;return;&#125;//AAAA ls[x]=ls[his];rs[x]=rs[his];sum[x]=sum[his]+1; if(w&lt;=mid) &#123; ls[x]=++cnt; update(w,l,mid,cnt,ls[his]); &#125; else &#123; rs[x]=++cnt; update(w,mid+1,r,cnt,rs[his]); &#125; //sum[x]=sum[ls[x]]+sum[rs[x]];&#125;void ask(int l,int r,int rx,int lx,int k)//当前点左 当前点右 当前右点 当前左点 第k小 &#123; if(l==r) &#123; ans=hash[l]; return; &#125; if(k&lt;=sum[ls[rx]]-sum[ls[lx]])//在左边 ask(l,mid,ls[rx],ls[lx],k); else//在右边 ask(mid+1,r,rs[rx],rs[lx],k-sum[ls[rx]]+sum[ls[lx]]);&#125;int main()&#123; int tx,ty,tk; n=read();m=read(); For(i,1,n) a[i]=read(); memcpy(hash,a,sizeof a); sort(hash+1,hash+n+1); len=unique(hash+1,hash+n+1)-hash-1; root[0]=++cnt; build(1,len,cnt); For(i,1,n) &#123; root[i]=++cnt; update(getHash(a[i]),1,len,cnt,root[i-1]); &#125; For(i,1,m) &#123; tx=read();ty=read();tk=read(); if(tx==ty) &#123;printf(\"%d\\n\",a[tx]);continue;&#125; ask(1,len,root[ty],root[tx-1],tk); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.sxyoi.cn/tags/数据结构/"},{"name":"主席树","slug":"主席树","permalink":"http://www.sxyoi.cn/tags/主席树/"}]},{"title":"博客迁移","slug":"博客迁移","date":"2018-08-30T09:44:45.000Z","updated":"2018-08-30T09:50:34.681Z","comments":true,"path":"2018/08/30/博客迁移/","link":"","permalink":"http://www.sxyoi.cn/2018/08/30/博客迁移/","excerpt":"","text":"其他博客地址： csdn：https://blog.csdn.net/suxuyu01 Luogu：https://www.luogu.org/blog/lqyzsun/ 一般情况下不会再使用，如果在除此博客之外的地方发了我认为有价值的新文章也搬到这里来","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://www.sxyoi.cn/tags/日志/"}]}]}